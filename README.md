**All comments within the code are generated by copilot   <img src="img.png" alt="drawing" width="20" style="vertical-align:middle"/>**

## 1. 创建型模式 (Creational Patterns)
<img src="img.png" alt="drawing" width="20" style="vertical-align:middle"/>   创建型模式关注对象的创建过程。这些模式提供了一种在不暴露对象创建逻辑的情况下创建对象的方式，目的是提高系统的灵活性和可复用性。

特点：将对象的创建和使用分离，减少了系统中对象创建的复杂度。
常见模式:  
**工厂模式 (Factory Method)**：定义一个接口用于创建对象，但由子类决定实例化哪一个类  
**抽象工厂模式 (Abstract Factory)**：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类  
**单例模式 (Singleton)**：确保一个类只有一个实例，并提供一个全局访问点  
**建造者模式 (Builder)**：将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示  
**原型模式 (Prototype)**：通过复制现有的实例来创建对象，而不是通过类构造器  
## 2. 结构型模式 (Structural Patterns)
<img src="img.png" alt="drawing" width="20" style="vertical-align:middle"/>   结构型模式涉及如何组合类和对象以形成更大的结构。这些模式帮助类和对象之间的关系得以更好地组织和使用，尤其是在不同的对象之间进行组合和分解时。

特点：关注对象的组合方式，确保系统的结构更加灵活和高效。
常见模式:  
**适配器模式 (Adapter)**：将一个类的接口转换成客户希望的另一个接口，以使不兼容的类能够一起工作  
**桥接模式 (Bridge)**：将抽象部分与实现部分分离，使它们都可以独立地变化  
**组合模式 (Composite)**：允许你将对象组合成树形结构来表示部分-整体的层次结构  
**装饰模式 (Decorator)**：动态地向一个对象添加一些额外的职责  
**外观模式 (Facade)**：为子系统中的一组接口提供一个一致的界面  
**享元模式 (Flyweight)**：运用共享技术有效地支持大量细粒度的对象  
**代理模式 (Proxy)**：为另一个对象提供一个替代者或占位符，以控制对它的访问  
## 3. 行为型模式 (Behavioral Patterns)
<img src="img.png" alt="drawing" width="20" style="vertical-align:middle"/>   行为型模式关注对象之间的职责分配和交互。这些模式定义了类之间的通信方式，并着重描述对象的职责和算法。

特点：关注对象间的交互方式，确保对象能够协同工作以完成任务。
常见模式:  
**责任链模式 (Chain of Responsibility)**：为请求创建一个接收者对象的链  
**命令模式 (Command)**：将请求封装为对象，从而使你可以用不同的请求对客户进行参数化  
**解释器模式 (Interpreter)**：为语言创建解释器，定义该语言的文法表示  
**迭代器模式 (Iterator)**：提供一种方法顺序访问一个集合中的各个元素，而不暴露其内部的表示  
**中介者模式 (Mediator)**：用一个中介对象来封装一系列对象的交互  
**备忘录模式 (Memento)**：在不破坏封装性的前提下，捕获并保存一个对象的内部状态，以便日后恢复  
**观察者模式 (Observer)**：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都能得到通知并自动更新  
**状态模式 (State)**：允许一个对象在其内部状态改变时改变其行为  
**策略模式 (Strategy)**：定义一系列算法，并将每一个算法封装起来，使它们可以相互替换  
**模板方法模式 (Template Method)**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中实现  
**访问者模式 (Visitor)**：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作  

# 设计模式的六大原则
### <img src="img.png" alt="drawing" width="20" style="vertical-align:middle"/>1、开闭原则（Open Close Principle）

开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

### <img src="img.png" alt="drawing" width="20" style="vertical-align:middle"/>2、里氏代换原则（Liskov Substitution Principle）

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

### <img src="img.png" alt="drawing" width="20" style="vertical-align:middle"/>3、依赖倒转原则（Dependence Inversion Principle）

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

### <img src="img.png" alt="drawing" width="20" style="vertical-align:middle"/>4、接口隔离原则（Interface Segregation Principle）

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

### <img src="img.png" alt="drawing" width="20" style="vertical-align:middle"/>5、迪米特法则，又称最少知道原则（Demeter Principle）

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

### <img src="img.png" alt="drawing" width="20" style="vertical-align:middle"/>6、合成复用原则（Composite Reuse Principle）

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。